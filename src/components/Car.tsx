import { useRef, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import { RigidBody, RapierRigidBody } from '@react-three/rapier'
import type { Controls } from '../hooks/useControls'
import * as THREE from 'three'

interface CarProps {
  controls: Controls
}

function Car({ controls }: CarProps) {
  const { nodes, materials } = useGLTF('/models/car.glb') as any
  const chassisRef = useRef<RapierRigidBody>(null)
  const wheelRefs = [
    useRef<THREE.Group>(null),
    useRef<THREE.Group>(null),
    useRef<THREE.Group>(null),
    useRef<THREE.Group>(null),
  ]

  // ??????? ???? ????? - ????? ???????????? ??? ?????????? ????????? ??????
  const wheelNames = ['wheel_fl', 'wheel_fr', 'wheel_rl', 'wheel_rr']
  const wheels = wheelNames.map((name) => {
    const wheelNode = Object.values(nodes).find(
      (node: any) => node.name && node.name.toLowerCase().includes(name.toLowerCase())
    ) as THREE.Mesh | undefined
    
    if (!wheelNode) {
      const allNodes = Object.values(nodes)
      const possibleWheels = allNodes.filter((node: any) => 
        node.name && (
          node.name.toLowerCase().includes('wheel') ||
          node.name.toLowerCase().includes('tyre') ||
          node.name.toLowerCase().includes('tire')
        )
      )
      return possibleWheels[wheelNames.indexOf(name)] || null
    }
    return wheelNode
  })

  const availableMeshes = Object.values(nodes).filter(
    (node: any) => node.isMesh && node.geometry
  ) as THREE.Mesh[]

  const finalWheels = wheels.every(w => w) ? wheels : availableMeshes.slice(0, 4)

  // ??????? ????? ???????????? ?????? ?????? (x, y, z)
  // x: ????/?????, y: ?????/????, z: ?????/???
  // ??????? ????? ???????????? ?????? ?????? (x, y, z)
  // x: ????/?????, y: ?????/????, z: ?????/???
  const wheelPositions = [
    [-1.0, -0.5, 1.2],   // ???????? ?????
    [1.0, -0.5, 1.2],    // ???????? ??????
    [-1.0, -0.5, -1.2],  // ?????? ?????
    [1.0, -0.5, -1.2],   // ?????? ??????
  ]

  // ????????? ??????????
  const currentEngineForce = useRef(0)
  const currentBrakeForce = useRef(0)
  const currentSteerValue = useRef(0)
  const wheelRotations = useRef([0, 0, 0, 0]) // ???????? ?????

  // ????????? ??????
  const maxForce = 150
  const maxBrakeForce = 50
  const maxSteerValue = 0.5
  const lerpSpeed = 0.1
  const wheelRadius = 0.4
  const wheelAngularVelocity = useRef(0)

  // ?????????? ??????? (??????????? ??????????)
  const cameraTheta = useRef(Math.PI / 4) // ?????????????? ???? (0 - 2?)
  const cameraPhi = useRef(Math.PI / 3) // ???????????? ???? (0 - ?)
  const cameraRadius = useRef(8) // ?????????? ?? ??????
  const isDragging = useRef(false)
  const lastTouchPos = useRef({ x: 0, y: 0 })
  const cameraTargetTheta = useRef(Math.PI / 4)
  const cameraTargetPhi = useRef(Math.PI / 3)

  // ????????? touch ??????? ??? ?????????? ???????
  useEffect(() => {
    const handleTouchStart = (e: TouchEvent) => {
      if (e.touches.length === 1) {
        isDragging.current = true
        lastTouchPos.current = {
          x: e.touches[0].clientX,
          y: e.touches[0].clientY
        }
      }
    }

    const handleTouchMove = (e: TouchEvent) => {
      if (!isDragging.current || e.touches.length !== 1) return
      
      e.preventDefault()
      
      const deltaX = e.touches[0].clientX - lastTouchPos.current.x
      const deltaY = e.touches[0].clientY - lastTouchPos.current.y

      // ????????? ???? ??????
      const sensitivity = 0.01
      cameraTargetTheta.current -= deltaX * sensitivity
      cameraTargetPhi.current += deltaY * sensitivity

      // ???????????? ???????????? ????
      cameraTargetPhi.current = Math.max(0.1, Math.min(Math.PI - 0.1, cameraTargetPhi.current))

      lastTouchPos.current = {
        x: e.touches[0].clientX,
        y: e.touches[0].clientY
      }
    }

    const handleTouchEnd = () => {
      isDragging.current = false
    }

    // ????????? ?????????????? ????? (pinch-to-zoom)
    let initialDistance = 0
    const handleTouchStartMulti = (e: TouchEvent) => {
      if (e.touches.length === 2) {
        const touch1 = e.touches[0]
        const touch2 = e.touches[1]
        initialDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        )
      }
    }

    const handleTouchMoveMulti = (e: TouchEvent) => {
      if (e.touches.length === 2) {
        e.preventDefault()
        const touch1 = e.touches[0]
        const touch2 = e.touches[1]
        const currentDistance = Math.hypot(
          touch2.clientX - touch1.clientX,
          touch2.clientY - touch1.clientY
        )
        
        const delta = initialDistance - currentDistance
        cameraRadius.current = Math.max(3, Math.min(15, cameraRadius.current + delta * 0.01))
        initialDistance = currentDistance
      }
    }

    // ????????? ???? ??? ?????????? ?????????
    const handleMouseDown = (e: MouseEvent) => {
      if (e.button === 0) { // ????? ?????? ????
        isDragging.current = true
        lastTouchPos.current = {
          x: e.clientX,
          y: e.clientY
        }
      }
    }

    const handleMouseMove = (e: MouseEvent) => {
      if (!isDragging.current) return
      
      const deltaX = e.clientX - lastTouchPos.current.x
      const deltaY = e.clientY - lastTouchPos.current.y

      // ????????? ???? ??????
      const sensitivity = 0.01
      cameraTargetTheta.current -= deltaX * sensitivity
      cameraTargetPhi.current += deltaY * sensitivity

      // ???????????? ???????????? ????
      cameraTargetPhi.current = Math.max(0.1, Math.min(Math.PI - 0.1, cameraTargetPhi.current))

      lastTouchPos.current = {
        x: e.clientX,
        y: e.clientY
      }
    }

    const handleMouseUp = () => {
      isDragging.current = false
    }

    const handleWheel = (e: WheelEvent) => {
      e.preventDefault()
      cameraRadius.current = Math.max(3, Math.min(15, cameraRadius.current + e.deltaY * 0.01))
    }

    window.addEventListener('touchstart', handleTouchStart)
    window.addEventListener('touchstart', handleTouchStartMulti)
    window.addEventListener('touchmove', handleTouchMove)
    window.addEventListener('touchmove', handleTouchMoveMulti)
    window.addEventListener('touchend', handleTouchEnd)
    window.addEventListener('mousedown', handleMouseDown)
    window.addEventListener('mousemove', handleMouseMove)
    window.addEventListener('mouseup', handleMouseUp)
    window.addEventListener('wheel', handleWheel, { passive: false })

    return () => {
      window.removeEventListener('touchstart', handleTouchStart)
      window.removeEventListener('touchstart', handleTouchStartMulti)
      window.removeEventListener('touchmove', handleTouchMove)
      window.removeEventListener('touchmove', handleTouchMoveMulti)
      window.removeEventListener('touchend', handleTouchEnd)
      window.removeEventListener('mousedown', handleMouseDown)
      window.removeEventListener('mousemove', handleMouseMove)
      window.removeEventListener('mouseup', handleMouseUp)
      window.removeEventListener('wheel', handleWheel)
    }
  }, [])

  useFrame((_, delta) => {
    if (!chassisRef.current) return

    const chassisBody = chassisRef.current

    // ????????? ??????? ???? ?????????
    let targetForce = 0
    if (controls.forward) {
      targetForce = maxForce
    } else if (controls.backward) {
      targetForce = -maxForce
    }

    // ????????? ??????? ????????? ??????
    let targetBrake = 0
    if (controls.backward && !controls.forward) {
      targetBrake = maxBrakeForce
    } else if (!controls.forward && !controls.backward) {
      targetBrake = maxBrakeForce * 0.3
    }

    // ????????? ??????? ???????? ???????? ??????????
    let targetSteer = 0
    if (controls.left) {
      targetSteer = maxSteerValue
    } else if (controls.right) {
      targetSteer = -maxSteerValue
    }

    // ??????? ????????????
    currentEngineForce.current = THREE.MathUtils.lerp(
      currentEngineForce.current,
      targetForce,
      lerpSpeed * 10
    )
    currentBrakeForce.current = THREE.MathUtils.lerp(
      currentBrakeForce.current,
      targetBrake,
      lerpSpeed * 10
    )
    currentSteerValue.current = THREE.MathUtils.lerp(
      currentSteerValue.current,
      targetSteer,
      lerpSpeed * 15
    )

    // ????????? ???? ? ?????? ??????? (RWD)
    // ?????????? ????????? ?????????? ??? ??????????? ????
    const rotation = chassisBody.rotation()
    const quaternion = new THREE.Quaternion(rotation.x, rotation.y, rotation.z, rotation.w)
    const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(quaternion)

    // ???? ?????????
    if (Math.abs(currentEngineForce.current) > 0.1) {
      const force = forward.multiplyScalar(currentEngineForce.current)
      chassisBody.applyImpulse(
        { x: force.x, y: force.y, z: force.z },
        true
      )
    }

    // ?????????? - ????????? ???????? ? ??????? ????????
    if (currentBrakeForce.current > 0.1) {
      const linvel = chassisBody.linvel()
      const brakeImpulse = {
        x: -linvel.x * currentBrakeForce.current * 0.1,
        y: -linvel.y * currentBrakeForce.current * 0.1,
        z: -linvel.z * currentBrakeForce.current * 0.1,
      }
      chassisBody.applyImpulse(brakeImpulse, true)

      const angvel = chassisBody.angvel()
      const brakeAngularImpulse = {
        x: -angvel.x * currentBrakeForce.current * 0.05,
        y: -angvel.y * currentBrakeForce.current * 0.05,
        z: -angvel.z * currentBrakeForce.current * 0.05,
      }
      chassisBody.applyTorqueImpulse(brakeAngularImpulse, true)
    }

    // ??????? ?????????? - ??????? ?????? ???????????? ???
    if (Math.abs(currentSteerValue.current) > 0.01) {
      const steerTorque = currentSteerValue.current * 50
      chassisBody.applyTorqueImpulse({ x: 0, y: steerTorque, z: 0 }, true)
    }

    // ????????? ?????????? ???????? ?????
    const linvel = chassisBody.linvel()
    const speed = Math.sqrt(linvel.x ** 2 + linvel.z ** 2)
    wheelAngularVelocity.current = speed / wheelRadius

    wheelRotations.current = wheelRotations.current.map((rot, index) => {
      return rot + wheelAngularVelocity.current * delta * (index >= 2 ? (currentEngineForce.current > 0 ? 1 : -1) : 1)
    })

    // ????????? ??????? ? ???????? ????? ?????????
    wheelRefs.forEach((ref, index) => {
      if (ref.current && chassisBody && index < wheelPositions.length) {
        const chassisPos = chassisBody.translation()
        const chassisRot = chassisBody.rotation()
        const chassisQuaternion = new THREE.Quaternion(chassisRot.x, chassisRot.y, chassisRot.z, chassisRot.w)

        // ???????????? ??????? ???????????? ??????
        // ?????????? ?????????? ?????????? ?? ??????? wheelPositions
        const [x, y, z] = wheelPositions[index]
        const localPos = new THREE.Vector3(x, y, z)
        const worldPos = localPos.applyQuaternion(chassisQuaternion)
        
        // ????????????? ??????? ??????, ??????? ???????? ??????
        ref.current.position.set(
          chassisPos.x + worldPos.x,
          chassisPos.y + worldPos.y,
          chassisPos.z + worldPos.z
        )

        // ??????? ??????
        const steerQuaternion = new THREE.Quaternion().setFromAxisAngle(
          new THREE.Vector3(0, 1, 0),
          currentSteerValue.current * (index < 2 ? 1 : 0) // ?????? ???????? ?????? ??????????????
        )
        const wheelQuaternion = chassisQuaternion.clone().multiply(steerQuaternion)
        
        // ???????? ????? ?????? ??? ?????? (??? Z ??? ??????????? ??????? ?????)
        // ??????? ?????? ???: Y ??? ???????? ?????? ?????????????? ???, ??? Z ??? ???????? ?????? ???????????? ???
        const rotationQuaternion = new THREE.Quaternion().setFromAxisAngle(
          new THREE.Vector3(0, 1, 0), // ??? Y ??? ???????? ??????
          wheelRotations.current[index]
        )
        wheelQuaternion.multiply(rotationQuaternion)
        
        ref.current.quaternion.copy(wheelQuaternion)
      }
    })
  })

  // ?????????? ??????? - ???????? ?????? ??????
  useFrame(({ camera }, delta) => {
    if (!chassisRef.current) return
    
    // ??????? ???????????? ????? ??????
    cameraTheta.current = THREE.MathUtils.lerp(
      cameraTheta.current,
      cameraTargetTheta.current,
      delta * 5
    )
    cameraPhi.current = THREE.MathUtils.lerp(
      cameraPhi.current,
      cameraTargetPhi.current,
      delta * 5
    )
    
    const chassisPosition = chassisRef.current.translation()
    
    // ????????? ??????? ?????? ? ??????????? ???????????
    const x = chassisPosition.x + cameraRadius.current * Math.sin(cameraPhi.current) * Math.cos(cameraTheta.current)
    const y = chassisPosition.y + cameraRadius.current * Math.cos(cameraPhi.current) + 2 // ???????? ?????
    const z = chassisPosition.z + cameraRadius.current * Math.sin(cameraPhi.current) * Math.sin(cameraTheta.current)
    
    const targetPosition = new THREE.Vector3(x, y, z)
    
    // ??????? ???????? ?????? ? ??????? ???????
    camera.position.lerp(targetPosition, delta * 5)
    
    // ?????? ?????? ??????? ?? ??????
    camera.lookAt(chassisPosition.x, chassisPosition.y + 1, chassisPosition.z)
  })

  return (
    <group>
      {/* ????? ?????? */}
      <RigidBody
        ref={chassisRef}
        type="dynamic"
        position={[0, 2, 0]}
        colliders="hull"
        mass={800}
        linearDamping={0.4}
        angularDamping={0.4}
      >
        {nodes && Object.keys(nodes).length > 0 ? (
          <group>
            {Object.values(nodes).map((node: any, index) => {
              if (node.isMesh && !finalWheels.includes(node)) {
                return (
                  <primitive
                    key={index}
                    object={node.clone()}
                    material={materials[node.material?.name || 'default']}
                  />
                )
              }
              return null
            })}
          </group>
        ) : (
          <mesh>
            <boxGeometry args={[2, 0.5, 4]} />
            <meshStandardMaterial color="red" />
          </mesh>
        )}
      </RigidBody>

      {/* ?????? */}
      {finalWheels.map((wheel: any, index) => {
        if (!wheel || !wheel.geometry) return null
        
        // ????????? ?????? ? ?????????? ??? ??????? ?? ??????
        const clonedWheel = wheel.clone()
        clonedWheel.position.set(0, 0, 0)
        clonedWheel.rotation.set(0, 0, 0)
        clonedWheel.scale.set(1, 1, 1)
        
        return (
          <group key={index} ref={wheelRefs[index]}>
            <primitive
              object={clonedWheel}
              material={materials[wheel.material?.name || 'default']}
            />
          </group>
        )
      })}
    </group>
  )
}

useGLTF.preload('/models/car.glb')

export default Car
